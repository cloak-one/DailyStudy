## 前置知识

### 函数与方法

**函数（function）**可以被独立执行，所有参数都以显式传递。

​	eg : C Language

<img src="Java%E7%9F%A5%E8%AF%86.assets/Snipaste_2023-09-24_22-21-56.png" style="zoom:50%;" />

**方法（method）**与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。

​	eg : Java

<img src="Java%E7%9F%A5%E8%AF%86.assets/Snipaste_2023-09-24_22-22-30.png" style="zoom:70%;" />

下面以几个常见的编程语言来说明。

- C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他语言中的方法。
- Java 和 C# 是面向对象的编程语言，代码块（方法）通常都是作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。
- C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。



### 变量

#### 分类

**成员变量和局部变量**

在方法体外，类体内声明的变量称为成员变量。 

在方法体内部等位置声明的变量称为局部变量

![image-20240109194907076](Java%E7%9F%A5%E8%AF%86.assets/image-20240109194907076-17048009513521.png)

- 其中修饰符static将成员变量分为实例变量和类变量

#### 成员变量和局部变量的异同

相同点：

- 声明格式相同
- 均需要先声明、后初始化、再使用
- 有对应的作用域

不同点：

1、声明位置和方式 （1）实例变量：在类中方法外 （2）局部变量：在方法体 {}中或方法的形参列表、代码块中 

2、在内存中存储的位置不同 （1）实例变量：堆 （2）局部变量：栈 

3、生命周期 （1）实例变量：和对象的生命周期一样，随着对象的创建而存 在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的。 （2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随 着方法执行的结束而消亡， 而且每一次方法调用都是独立。 

4、作用域 （1）实例变量：通过对象就可以使用，本类中直接调用，其他类中 “对象.实例变量” （2）局部变量：出了作用域就不能使用 

5、修饰符

（1）实例变量： public,protected,private,final,volatile,transient 等 （2）局部变量：final 

6、默认值 （1）实例变量：有默认值 （2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。

#### 对象属性的默认初始化赋值

当一个对象被创建时，会对其中各种类型的**成员**变量自动进行初始化赋值

![image-20240109200154081](Java%E7%9F%A5%E8%AF%86.assets/image-20240109200154081-17048017166243-17048019205553.png)



### 字符编码

#### ASCII 字符集

- ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。
- ASCII码用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。
- 基本的ASCII字符集，使用7位（bits）表示一个字符（最前面的1位统一规定为0），共128个字符。比如：空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。
- 缺点：不能表示所有字符。

<img src="Java%E7%9F%A5%E8%AF%86.assets/ascii_table.png" alt="img" style="zoom:250%;" />

####  ISO-8859-1字符集

- 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰语、德语、意大利语、葡萄牙语等
- ISO-8859-1使用单字节编码，兼容ASCII编码。

#### GBxxx字符集

- GB就是国标的意思，是为了显示中文而设计的一套字符集。
- **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同，即向下兼容ASCII码。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这就是常说的"全角"字符，而原来在127号以下的那些符号就叫"半角"字符了。
- **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
- **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。

#### Unicode码

- Unicode编码为表达任意语言的任意字符而设计，也称为统一码、标准万国码。Unicode 将世界上所有的文字用2个字节统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求。
- Unicode 的缺点：这里有三个问题：

- - 第一，英文字母只用一个字节表示就够了，如果用更多的字节存储是极大的浪费。
  - 第二，如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？
  - 第三，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。

- Unicode在很长一段时间内无法推广，直到互联网的出现，为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现。具体来说，有三种编码方案，UTF-8、UTF-16和UTF-32。

<img src="Java%E7%9F%A5%E8%AF%86.assets/unicode_hello_algo.png" alt="Unicode 编码示例" style="zoom:120%;" />

#### UTF-8 编码

目前，UTF-8 已成为国际上使用最广泛的 Unicode 编码方法。**它是一种可变长的编码**，使用 1 到 4 个字节来表示一个字符，根据字符的复杂性而变。ASCII 字符只需要 1 个字节，拉丁字母和希腊字母需要 2 个字节，常用的中文字符需要 3 个字节，其他的一些生僻字符需要 4 个字节。

UTF-8 的编码规则并不复杂，分为以下两种情况。

- 对于长度为 1 字节的字符，将最高位设置为 0、其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，**UTF-8 编码可以向下兼容 ASCII 码**。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。
- 对于长度为 n 字节的字符（其中 n >1），将首个字节的高 n 位都设置为 1、第 n+1 位设置为 0 ；从第二个字节开始，将每个字节的高 2 位都设置为 10 ；其余所有位用于填充字符的 Unicode 码点。

图 3-8 展示了“Hello算法”对应的 UTF-8 编码。观察发现，由于最高 n 位都被设置为 1 ，因此系统可以通过读取最高位 1 的个数来解析出字符的长度为 n 。

但为什么要将其余所有字节的高 2 位都设置为 10 呢？实际上，这个 10 能够起到校验符的作用。假设系统从一个错误的字节开始解析文本，字节头部的 10 能够帮助系统快速的判断出异常。

之所以将 10 当作校验符，是因为在 UTF-8 编码规则下，不可能有字符的最高两位是 10 。这个结论可以用反证法来证明：假设一个字符的最高两位是 10 ，说明该字符的长度为 1 ，对应 ASCII 码。而 ASCII 码的最高位应该是 0 ，与假设矛盾。

*图 3-8  UTF-8 编码示例*

![UTF-8 编码示例](Java%E7%9F%A5%E8%AF%86.assets/utf-8_hello_algo.png)

除了 UTF-8 之外，常见的编码方式还包括以下两种。

- **UTF-16 编码**：使用 2 或 4 个字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 个字节表示；少数字符需要用到 4 个字节表示。对于 2 字节的字符，UTF-16 编码与 Unicode 码点相等。
- **UTF-32 编码**：每个字符都使用 4 个字节。这意味着 UTF-32 会比 UTF-8 和 UTF-16 更占用空间，特别是对于 ASCII 字符占比较高的文本。

从存储空间的角度看，使用 UTF-8 表示英文字符非常高效，因为它仅需 1 个字节；使用 UTF-16 编码某些非英文字符（例如中文）会更加高效，因为它只需要 2 个字节，而 UTF-8 可能需要 3 个字节。

从兼容性的角度看，UTF-8 的通用性最佳，许多工具和库都优先支持 UTF-8 。

## 重点知识

### 面向对象编程

**子类构造器中调用父类构造器**  

① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方 式调用父类指定的构造器。 

② 规定：“super(形参列表)”，必须声明在构造器的首行。

③ 我们前面讲过，在构造器的首行可以使用"this(形参列表)"，调用本类中重载 的构造器， 结合②，结论：在构造器的首行，"this(形参列表)" 和 "super(形 参列表)"只能二选一。 

④ 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用 "super(形参列表)"， 则子类此构造器默认调用"super()"，即调用父类中空参的 构造器。 

⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构 造器，要么会调用父类的构造器。 只能是这两种情况之一。 

⑥ 由⑤得到：一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了 "this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。 

#### this和super

1、this 和 super 的意义 

this：当前对象 

1. 在构造器和非静态代码块中，表示正在 new 的对象 
2. 在实例方法中，表示调用当前方法的对象 

super：引用父类声明的成员 

2、this 和 super 的使用格式 

• this

- this.成员变量：表示当前对象的某个成员变量，而不是局部变量 
-  this.成员方法：表示当前对象的某个成员方法，完全可以省略 this. 
-  this()或 this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在 构造器首行，只会找本类的构造器，找不到就报错 

• super 

-  super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明 的 
-  super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的 
-  super()或 super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错

PS：**开发中常见错误： 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则编译出错。**

```java
/*
1、私有的属性是否可以被继承到子类中？
（1）如果从可以访问性的角度来说
不能，因为在子类中不能直接访问父类的私有的属性，但是可以通过get/set操作
（2）如果从类的概念来说
类是一类具有相同特性（属性、方法等）的事物的抽象描述，
那么子类是从父类派生出来的，那么子类是有父类的这个特征的，即有这个属性的

2、每一个对象的非静态属性是独立的，其中一个对象修改和另一个对象是无关的

3、当子类有与父类的属性同名时，那么通过子类对象调用get/set方法操作的是父类继承还是子类自己的属性呢？
要看子类是否重写：
如果没有重写，操作的都是父类的，不管是直接getInfo()还是this.getInfo()，还是super.getInfo()
如果重写了，如果通过子类对象调用，操作的是子类的，例如：getInfo()还是this.getInfo()，如果通过super.调用的，操作的是父类的。
*/
```



#### 多态

Java 引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量 时使用的类型决定，运行时类型由实际赋给该变量的对象决定。

**简称：编译时， 看左边；运行时，看右边。**

 • 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) 

• 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法） “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法） 

多态的使用前提：① 类的继承关系 ② 方法的重写

**1.多态的分类**

1. 方法内局部变量的赋值体现多态
2. 方法的形参声明体现多态
3. 方法返回值类型体现多态

实质：通过父类调用子类的重写方法，一定存在把子类对象赋值给父类变量的过程

**2.意义**

多态性(polymorphism)的意义：开发中，有时我们在设计一个数组、或一个成员变量、或一个方法的形参、返 回值类型时，无法确定它具体的类型，只能确定它是某个系列的类型，利用多态解决。

**3.好处和弊端**

好处：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编 写更灵活、功能更强大，可维护性和扩展性更好了。

 弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象， 那么该变量就不能再访问子类中添加的属性和方法。

- 开发中： 使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子 类，方法也无需改变，提高了扩展性，符合开闭原则。

**4.向上转型和向下转型**

向上转型：自动完成

- 编译时按照左边变量的类型处理，就只能调用父类中有的变量和方 法，不能调用子类特有的变量和方法了 

向下转型：（子类类型）父类变量

- 不是所有通过编译的向下转型都是正确的，可能会发生 ClassCastException，为了安全，可以通过 isInstanceof 关键字进行判断

#### 实例变量赋值顺序

![image-20240121115408697](Java%E7%9F%A5%E8%AF%86.assets/image-20240121115408697-17058092532361.png)

如果在类加载过程中存在变量的实例化时，只需要加载非静态的初始化。

```java
	public static Exer13 t1 = new Exer13("t1");
    public static Exer13 t2 = new Exer13("t2");
```



#### Object的使用

1、equals()

**==和 equals 的区别**

- == 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用 类型就是比较内存地址 
- equals 的话，它是属于 java.lang.Object 类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到 String 等类的 equals 方法是被重写过的，而且 String 类在日常开发中用的比较多，久而久之，形成了 equals 是比较值的错误观点.
- 具体要看自定义类里有没有重写 Object 的 equals 方法来判断。 

通常情况下，重写 equals 方法，会比较类中的相应属性是否都相等。

2、toString()

1. 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的 hashCode 值 的十六进制形式"
2. 在进行 String 与其它类型数据的连接操作时，自动调用 toString()方法
3. 如果我们直接 System.out.println(对象)，默认会自动调用这个对象的 toString()
   - 因为 Java 的引用数据类型的变量中存储的实际上时对象的内存地址， 但是 Java 对程序员隐藏内存地址信息，所以不能直接将内存地址显示 出来，所以当你打印对象时，JVM 帮你调用了对象的 toString()
4. 可以根据需要在用户自定义类型中重写 toString()方法 如 String 类重写了 toString()方法，返回字符串的值。

3、clone()

4、getClass()

public final Class getClass()：获取对象的运行时类型 

因为 Java 有多态现象，所以一个引用数据类型的变量的编译时类型与 运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象 的类型，需要用 getClass()方法 

```java
public static void main(String[] args) {
    Object obj = new Person();
    System.out.println(obj.getClass());//运行时类型
}
```

 结果： 

```Java
class com.atguigu.java.Person
```

5、hashCode()

public int hashCode()：返回每个对象的 hash 值。

6、~~finalize()~~

对象回收时调用的方法（JDK 9中标记过时方法）

#### 代码块

静态代码块：静态代码块随着类的加载而加载，且只执行一次。

非静态代码块：随着对象的创建而执行，先于构造器执行。

**实例变量赋值位置以及顺序**

1. 默认初始化
2. 显式初始化、代码块中初始化（同级别下按照先后顺序赋值）
3. 构造器中初始化
4. 通过“对象.属性”或者是“对象.方法”多次给属性赋值

#### 注解

**1.元注解**

JDK1.5 在 java.lang.annotation 包定义了 4 个标准的 meta-annotation 类型，它 们被用来提供对其它 annotation 类型作说明。

1. @Target：用于描述注解的使用范围 
   - 可以通过枚举类型 ElementType 的 10 个常量对象来指定 
   - TYPE，METHOD，CONSTRUCTOR，PACKAGE..... 
2. @Retention：用于描述注解的生命周期
   - 可以通过枚举类RetentionPolicy 的 3 个常量对象来指定 
   - SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）
   - 唯有 RUNTIME 阶段才能被反射读取到。 
3. @Documented：表明这个注解应该被 javadoc 工具记录。
4. @Inherited：允许子类继承父类中的注解
5. @native(JDK 1.8)
6. @Repeatable(JDK 1.8)

**2.自定义注解**

一个完整的注解应该包含三个部分： （1）声明 （2）使用 （3）读取

![image-20240114172306130](Java%E7%9F%A5%E8%AF%86.assets/image-20240114172306130-17052241902911.png)

1. 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为 value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名 value。
   - eg:@Table(value = "xxx")  <=> @Table("xxx")  由于只有一个抽象方法，且方法名为value，则value =可以省略
2. 自定义注解必须配上注解的信息处理流程才有意义。 我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期 必须是 RetentionPolicy.RUNTIME。

#### 包装类

包装类、String类、基本数据类型的转换

![image-20240114224907020](Java%E7%9F%A5%E8%AF%86.assets/image-20240114224907020.png)

**包装类缓存对象**

<img src="Java%E7%9F%A5%E8%AF%86.assets/image-20240114224803213-17052436851393.png" alt="image-20240114224803213" style="zoom:67%;" />

```java
Integer a = 1;
Integer b = 1;
System.out.println(a == b);//true

Integer i = 128;
Integer j = 128;
System.out.println(i == j);//false

Double d1 = 1.0;
Double d2 = 1.0;
System.out.println(d1==d2);//false 比较地址，没有缓存对象，每一个都是新new,float同理 
```

**包装类对象不可变 **

```java
public class TestExam{
   public static void main(String[] args) {

        int i = 1;
        Integer j = new Integer(2);
        Circle c = new Circle();
        change(i,j,c);
        System.out.println("i = " + i);//1
        System.out.println("j = " + j);//2
        System.out.println("c.radius = " + c.radius);//10.0

   }
   /*
    * 方法的参数传递机制：
    * （1）基本数据类型：形参的修改完全不影响实参
    * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值
    * 这类 Integer 等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了
	*/ 
    public static void change(int a ,Integer b,Circle c ){
        a += 10;
        // b += 10;//等价于 b = new Integer(b+10);
        c.radius += 10;
        /*c = new Circle();
        c.radius+=10;*/
	} 
}
class Circle{double radius;}
```

